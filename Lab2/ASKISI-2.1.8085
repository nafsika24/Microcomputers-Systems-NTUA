IN 10H
MVI E,FFH	;Μεταφέρω το 255 στην είσοδο
LXI H,0900H	;Ορίζω τη διεύθυνση όπου θα αρχίσουν να αποθηκεύονται οι αριθμοί

;Α ΜΈΡΟΣ
START:
MOV M,E	;Αποθηκεύω το 255 στη μνήμη
DCR E		;Αποθηκεύω τους αριθμούς 255-0 διαδοχικά
INX H
MOV A,E
CPI 00H
JNZ START	;Επανάληψη μέχρι να αποθηκευτούν όλοι οι αριθμοί

;Β ΜΈΡΟΣ
LXI H,0900H 	;Μεταφέρω τον HL ξανά στη θέση 0900H 
MVI D,00H	;D=0
MVI E,08H	;E=8(αρχικοποιώ τον DE στο 8 διότι ο αριθμός 0 έχει 8 μηδενικά σίγουρα) 
MVI C,08H	;C=8  μετρητής για τα ψηφία κάθε αριθμού
MVI B,00H

NUMBERS:
MOV A,M	;Α=255 

SET:
MOV B,A		
MOV A,C
CPI 00H	;Ελέγχω εάν η μέτρηση έφτασε στο 0
JZ NEXT
MOV A,B
DCR C		
RRC		;Δεξιά περιστροφή για να εξεταστεί κάθε ένα ψηφίο κάθε αριθμού
JC SET		;Εάν το ψηφίο είναι 0 
INX D		;Αύξηση του περιεχομένου του DE κατά 1

JMP SET	;Επανάληψη μέχρι να εξεταστούν όλα τα ψηφία του κάθε αριθμού

NEXT:		;Επόμενος αριθμός
INX H
MOV A,M
CPI 00H
JZ THIRD_PART	;Εάν ο επόμενος είναι  το 0, δηλαδή η μέτρηση τελείωσε jump στο 3ο 			μέρος
MVI C,08H	;Αλλιώς C?8 και έλεγχος των ψηφίων του επόμενου αριθμού


JMP NUMBERS	;και έλεγχος των ψηφίων του επόμενου αριθμού

;Γ ΜΈΡΟΣ
THIRD_PART:
LXI H,0900H 	;Μεταφέρω τον HL ξανά στη θέση 0900H 
MVI C,01H	;C=0 αρχικοποιώ τον μετρητή για τους ζητούμενους αριθμούς

BEGIN:
MOV A,M
CPI 21H	;Σύγκριση με το 21H
JC WRONG	;Εάν είναι μικρότερος “απορρίπτεται” jump στην WRONG
CPI 71H	;Σύγκριση με το 71H
JNC WRONG	;Εάν είναι μεγαλύτερος “απορρίπτεται” jump στην WRONG

INR C


WRONG:

INX H		;Αυξάνω τη διεύθυνση με τους αριθμούς κατά 1
MOV A,M
CPI 00H	;Ελέγχω εάν το πρόγραμμα έφτασε στο 0
JZ END	
	;Εάν ναι το πρόγραμμα τελειώνει
JMP BEGIN	;Αλλιώς εξετάζω τη θέση του επόμενου αριθμού

END:
RST 1
END